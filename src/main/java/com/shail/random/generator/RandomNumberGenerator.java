package com.shail.random.generator;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.Callable;
import java.util.concurrent.CompletionService;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorCompletionService;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.shail.random.generator.task.RandomNumberConsumer;
import com.shail.random.generator.task.RandomNumberProducer;

/**
 * This class provides functionality to generate random numbers by levering
 * multiple threads to generate random numbers & then passing them to a 
 * single threaded consumer. Consumer is single threaded as Read Write on single
 * can cause contention and hence I am not parallelizing it.
 * 
 * Another approach could be to create multiple consumers & write to their own local files (parallel write)
 * And can be merged later on into single file.
 * @author shail
 *
 */
 
public class RandomNumberGenerator {
	
	private static Logger LOG = LoggerFactory.getLogger(RandomNumberGenerator.class);
	
	/**
	 * Number of producer threads
	 */
	private static final int PRODUCERS=4;
	
	/**
	 * Number of random numbers to be generated by each producer
	 */
	private static final int ITERATIONS=250000;
	
	public void generateNumbers(final String path) {
		
		LOG.info("RandomNumberGenerator started with param : "+path);
		//Create a fixed thread pool executor one thread for each producer & one for consumer
		final ExecutorService es=Executors.newFixedThreadPool(PRODUCERS+1);
		
		final CompletionService<Void> completionService = 
			       new ExecutorCompletionService<Void>(es);

		final ArrayBlockingQueue<List<Integer>> queue=new ArrayBlockingQueue<List<Integer>>(8,Boolean.TRUE);
		
		final Callable<Void> consumer=new RandomNumberConsumer(queue,path,ITERATIONS*PRODUCERS);
		
		//Submit consumer
		completionService.submit(consumer);
		
		final List<Callable<Void>> producers = getProducers(queue);
		
		//Submit producers
		producers.forEach(task -> completionService.submit(task));
		
		es.shutdown();
		
		int received = 0;
		boolean errors = false;
		
		//Checking if all tasks are completed or errored out.
		while(received < producers.size()+1 && !errors) {
			try {
				Future<Void> resultFuture = completionService.take();
				resultFuture.get();
				received++;
			} catch (InterruptedException e) {
				e.printStackTrace();
				errors=true;
			} catch (ExecutionException e) {
				e.printStackTrace();
				errors=true;
			}
		}
		LOG.info("RandomNumberGenerator execution completed.");
	}
	
	private List<Callable<Void>> getProducers(final BlockingQueue<List<Integer>> queue){
		List<Callable<Void>> producers=new ArrayList<>();
		int i=0;
		while (i<PRODUCERS) {
			producers.add(new RandomNumberProducer(ITERATIONS,queue));
			i++;
		}
		return producers;
	}

}
